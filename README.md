#Interviewing

This is a sample project to record questions i intend to use for interviewing people

## Philosophy
For most companies i have worked for i've built software intended to be used by people rather than libraries and implementing new algorithms.
My approach is towards pragramatic programming. Application engineers should be good at building applications, specifically
converting the domain objects and business rules into a piece of software using the tools available. 
If you are an engineer working on building new libraries for collections etc, you better how to implement the algorithms 
and the domain here would be computer science. 
If you are building lets say an account software, you better know the accounting domain. 
You also need to know the algorithms but maybe not as much in depth as the previous role. 
You really need to know how to use the available data structures to achieve your end outcome though by applying it the right away.

The questions in this repo are expected to help figure out if engineers can understand some domain rules quickly 
and solve the problem using standard java programming language features.

The things that help building durable software are:
* Ability to express think logically and solve a problem
* Ability to express your solution into computer instructions to make it solve the problem
* Ability to write clean software that consists of:
    * clean modular code
    * no smells
    * Good automated testing
    * Documentation within the code to help maintain it long term
    * Extensibility: Most software will be modified during its lifetime and writing code that is extensible will sometimes be what determines your success.
        Unfortunately this is also extremely hard to test in a quick coding interview.
    
A lot of interviews test the first 2 parts but very few test the later parts explicitly. 
The tests in this repo look for signals from the candidate in this space.

## Scaling questions
For the most part, i prefer leveling a candidate by asking them 1 question at a simple level 
and then increasing the complexity as much as possible.
This is done for 2 reasons:
* Tests the candidate's understanding of the domain 
* Tests the code they write for extensibility
* Tests the candidate's skill level (a junior candidate vs an extremely skilled senior level candidate)
 